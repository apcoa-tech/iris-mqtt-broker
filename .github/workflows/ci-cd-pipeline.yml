name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prd
      image_tag:
        description: 'Docker image tag (leave empty for auto-generated)'
        required: false
        default: ''

permissions:
  id-token: write
  contents: read

env:
  ACR_NAME: irisacrdev001
  IMAGE_NAME: mosquitto

jobs:
  # ============================================================
  # STAGE 0: Check what changed
  # ============================================================
  check-changes:
    name: ðŸ” Check Changes
    runs-on: ubuntu-latest
    outputs:
      docker_changed: ${{ steps.changes.outputs.docker }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for docker changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - check if specific image tag provided
            if [ -n "${{ github.event.inputs.image_tag }}" ]; then
              echo "docker=false" >> $GITHUB_OUTPUT
              echo "â­ï¸  Manual trigger with specific image tag - will skip build"
            else
              # Manual trigger without image tag - use existing latest image
              echo "docker=false" >> $GITHUB_OUTPUT
              echo "ðŸ“¦ Manual trigger - will use existing latest image"
            fi
          elif [ -n "${{ github.event.before }}" ]; then
            # Push event - check what files changed
            if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -qE '^docker/'; then
              echo "docker=true" >> $GITHUB_OUTPUT
              echo "ðŸ”¨ Docker files changed - will build new image"
            else
              echo "docker=false" >> $GITHUB_OUTPUT
              echo "â­ï¸  No docker changes - will use existing latest image"
            fi
          else
            # Fallback - use existing image
            echo "docker=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Using existing latest image (no before commit)"
          fi

  # ============================================================
  # STAGE 1: Build Docker Image (conditional)
  # ============================================================
  build:
    name: ðŸ”¨ Build Image
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.docker_changed == 'true'
    outputs:
      image_tag: ${{ steps.tags.outputs.tag }}
      image_full: ${{ steps.tags.outputs.full }}
      image_built: ${{ steps.tags.outputs.built }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: tags
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            TAG="$(date +%Y%m%d)-${GITHUB_SHA::8}"
          fi

          FULL_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:$TAG"

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "full=$FULL_TAG" >> $GITHUB_OUTPUT
          echo "built=true" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image tag: $TAG"

      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to Azure Container Registry
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build Docker image
        working-directory: docker
        run: |
          docker build \
            -t ${{ steps.tags.outputs.full }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:latest \
            --label "git.commit=${{ github.sha }}" \
            --label "git.branch=${{ github.ref_name }}" \
            --label "build.date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .

          echo "âœ… Image built successfully"

      - name: Scan image for vulnerabilities
        continue-on-error: true
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update && sudo apt-get install -y trivy

          trivy image --severity HIGH,CRITICAL --format table ${{ steps.tags.outputs.full }}

      - name: Push image to ACR
        run: |
          docker push ${{ steps.tags.outputs.full }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:latest

          echo "âœ… Image pushed: ${{ steps.tags.outputs.full }}"

  # ============================================================
  # STAGE 1b: Use existing image (if build skipped)
  # ============================================================
  use-existing-image:
    name: ðŸ“¦ Use Existing Image
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.docker_changed == 'false'
    outputs:
      image_tag: ${{ steps.existing.outputs.tag }}
      image_full: ${{ steps.existing.outputs.full }}
      image_built: ${{ steps.existing.outputs.built }}

    steps:
      - name: Set existing image tag
        id: existing
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            TAG="latest"
          fi

          FULL_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:$TAG"

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "full=$FULL_TAG" >> $GITHUB_OUTPUT
          echo "built=false" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Using existing image: $FULL_TAG"

  # ============================================================
  # STAGE 2: Deploy Certificates
  # ============================================================
  deploy-certificates:
    name: ðŸ” Deploy Certificates
    runs-on: ubuntu-latest
    needs: [check-changes, build, use-existing-image]
    if: always() && (needs.build.result == 'success' || needs.use-existing-image.result == 'success')
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      storage_account: ${{ steps.env.outputs.storage_account }}
      storage_key: ${{ steps.storage.outputs.storage_key }}
      image_tag: ${{ steps.image.outputs.tag }}
      image_full: ${{ steps.image.outputs.full }}
      image_built: ${{ steps.image.outputs.built }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine image to use
        id: image
        run: |
          if [ "${{ needs.build.result }}" == "success" ]; then
            echo "tag=${{ needs.build.outputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "full=${{ needs.build.outputs.image_full }}" >> $GITHUB_OUTPUT
            echo "built=${{ needs.build.outputs.image_built }}" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Using newly built image: ${{ needs.build.outputs.image_full }}"
          else
            echo "tag=${{ needs.use-existing-image.outputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "full=${{ needs.use-existing-image.outputs.image_full }}" >> $GITHUB_OUTPUT
            echo "built=${{ needs.use-existing-image.outputs.image_built }}" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Using existing image: ${{ needs.use-existing-image.outputs.image_full }}"
          fi

      - name: Load environment config
        id: env
        run: |
          ENV="${{ github.event.inputs.environment }}"
          if [ -z "$ENV" ]; then
            ENV="dev"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT

          source config/env.$ENV
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "storage_account=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get storage account key
        id: storage
        run: |
          STORAGE_KEY=$(az storage account keys list \
            --resource-group ${{ steps.env.outputs.resource_group }} \
            --account-name ${{ steps.env.outputs.storage_account }} \
            --query '[0].value' -o tsv)

          echo "storage_key=$STORAGE_KEY" >> $GITHUB_OUTPUT

      - name: Check if certificates exist
        id: cert_check
        env:
          AZURE_STORAGE_ACCOUNT: ${{ steps.env.outputs.storage_account }}
          AZURE_STORAGE_KEY: ${{ steps.storage.outputs.storage_key }}
        run: |
          CERTS_SHARE="iris-${{ steps.env.outputs.environment }}-mqtt-certs"

          if az storage file exists --share-name "$CERTS_SHARE" --path ca.crt --query exists -o tsv | grep -q true; then
            echo "cert_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Certificates already exist in Azure"
          else
            echo "cert_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  Certificates not found - will deploy"
          fi

      - name: Deploy production certificates
        if: steps.cert_check.outputs.cert_exists == 'false'
        env:
          AZURE_STORAGE_ACCOUNT: ${{ steps.env.outputs.storage_account }}
          AZURE_STORAGE_KEY: ${{ steps.storage.outputs.storage_key }}
        run: |
          mkdir -p /tmp/certs
          CERTS_SHARE="iris-${{ steps.env.outputs.environment }}-mqtt-certs"

          # Copy production certificates
          cp prd_broker_certs/ca.crt /tmp/certs/ca.crt
          cp prd_broker_certs/server.crt /tmp/certs/server.crt
          echo "${{ secrets.MQTT_SERVER_KEY }}" > /tmp/certs/server.key

          echo "ðŸ“¤ Uploading TLS certificates to $CERTS_SHARE..."

          az storage file upload --share-name "$CERTS_SHARE" \
            --source /tmp/certs/server.crt --path server.crt

          az storage file upload --share-name "$CERTS_SHARE" \
            --source /tmp/certs/server.key --path server.key

          az storage file upload --share-name "$CERTS_SHARE" \
            --source /tmp/certs/ca.crt --path ca.crt

          echo "âœ… TLS certificates uploaded"

  # ============================================================
  # STAGE 3: Deploy Configuration
  # ============================================================
  deploy-configuration:
    name: âš™ï¸ Deploy Config
    runs-on: ubuntu-latest
    needs: deploy-certificates
    outputs:
      deploy_dual_brokers: ${{ steps.env.outputs.deploy_dual_brokers }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load environment config
        id: env
        run: |
          ENV="${{ needs.deploy-certificates.outputs.environment }}"
          source config/env.$ENV

          echo "deploy_dual_brokers=$DEPLOY_DUAL_BROKERS" >> $GITHUB_OUTPUT
          echo "external_broker_address=$EXTERNAL_BROKER_ADDRESS" >> $GITHUB_OUTPUT
          echo "bridge_username=$BRIDGE_USERNAME" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Generate mosquitto.conf for mqtt-1
        if: steps.env.outputs.deploy_dual_brokers == 'true'
        env:
          BRIDGE_USERNAME: ${{ steps.env.outputs.bridge_username }}
          EXTERNAL_BROKER_ADDRESS: ${{ steps.env.outputs.external_broker_address }}
        run: |
          ./scripts/generate-config.sh \
            config/mosquitto-mqtt-1.conf.template \
            /tmp/mosquitto-1.conf

          echo "âœ… mosquitto.conf for mqtt-1 generated"

      - name: Generate mosquitto.conf for mqtt-2
        if: steps.env.outputs.deploy_dual_brokers == 'true'
        run: |
          ./scripts/generate-config.sh \
            config/mosquitto-mqtt-2.conf.template \
            /tmp/mosquitto-2.conf

          echo "âœ… mosquitto.conf for mqtt-2 generated"

      - name: Install Mosquitto tools
        run: |
          sudo apt-get update
          sudo apt-get install -y mosquitto mosquitto-clients
          echo "âœ… Mosquitto tools installed"

      - name: Setup user passwords from GitHub Secrets
        run: |
          echo "Setting up user passwords from GitHub Secrets..."

          # deviceuser password
          PASSWORD_DEVICEUSER="${{ secrets.MQTT_USER_DEVICEUSER_PASSWORD }}"
          echo "::add-mask::$PASSWORD_DEVICEUSER"
          echo "PASSWORD_DEVICEUSER=$PASSWORD_DEVICEUSER" >> $GITHUB_ENV

          # adminuser password
          PASSWORD_ADMINUSER="${{ secrets.MQTT_USER_ADMINUSER_PASSWORD }}"
          echo "::add-mask::$PASSWORD_ADMINUSER"
          echo "PASSWORD_ADMINUSER=$PASSWORD_ADMINUSER" >> $GITHUB_ENV

          # external_integration_user password
          PASSWORD_EXTERNAL_INTEGRATION_USER="${{ secrets.MQTT_BRIDGE_PASSWORD }}"
          echo "::add-mask::$PASSWORD_EXTERNAL_INTEGRATION_USER"
          echo "PASSWORD_EXTERNAL_INTEGRATION_USER=$PASSWORD_EXTERNAL_INTEGRATION_USER" >> $GITHUB_ENV

          echo "âœ… User passwords configured"

      - name: Generate MQTT authentication file
        run: |
          ./scripts/generate-password-file.sh \
            /tmp/password.txt \
            deviceuser,adminuser,external_integration_user

          echo "âœ… MQTT user credentials configured"

      - name: Upload configuration files
        env:
          AZURE_STORAGE_ACCOUNT: ${{ needs.deploy-certificates.outputs.storage_account }}
          AZURE_STORAGE_KEY: ${{ needs.deploy-certificates.outputs.storage_key }}
        run: |
          ENV="${{ needs.deploy-certificates.outputs.environment }}"

          # Upload mqtt-1 config
          az storage file upload \
            --share-name "iris-${ENV}-mqtt-1-config" \
            --source /tmp/mosquitto-1.conf \
            --path mosquitto.conf

          az storage file upload \
            --share-name "iris-${ENV}-mqtt-1-config" \
            --source /tmp/password.txt \
            --path password.txt

          # Upload mqtt-2 config
          az storage file upload \
            --share-name "iris-${ENV}-mqtt-2-config" \
            --source /tmp/mosquitto-2.conf \
            --path mosquitto.conf

          az storage file upload \
            --share-name "iris-${ENV}-mqtt-2-config" \
            --source /tmp/password.txt \
            --path password.txt

          echo "âœ… Configuration files uploaded"

  # ============================================================
  # STAGE 4: Restart Containers
  # ============================================================
  restart-containers:
    name: ðŸ”„ Restart Containers
    runs-on: ubuntu-latest
    needs: [deploy-configuration, deploy-certificates]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load environment config
        id: env
        run: |
          ENV="${{ needs.deploy-certificates.outputs.environment }}"
          source config/env.$ENV

          echo "container_group_1=$CONTAINER_GROUP_1" >> $GITHUB_OUTPUT
          echo "container_group_2=$CONTAINER_GROUP_2" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "deploy_dual_brokers=$DEPLOY_DUAL_BROKERS" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Restart mqtt-1 container
        run: |
          echo "ðŸ”„ Restarting ${{ steps.env.outputs.container_group_1 }}..."

          az container restart \
            --resource-group ${{ steps.env.outputs.resource_group }} \
            --name ${{ steps.env.outputs.container_group_1 }}

          echo "âœ… Container restarted"

      - name: Restart mqtt-2 container
        if: steps.env.outputs.deploy_dual_brokers == 'true'
        run: |
          echo "ðŸ”„ Restarting ${{ steps.env.outputs.container_group_2 }}..."

          az container restart \
            --resource-group ${{ steps.env.outputs.resource_group }} \
            --name ${{ steps.env.outputs.container_group_2 }}

          echo "âœ… Container restarted"

  # ============================================================
  # STAGE 5: Verify Deployment
  # ============================================================
  verify:
    name: âœ… Verify Deployment
    runs-on: ubuntu-latest
    needs: restart-containers

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load environment config
        id: env
        run: |
          ENV="${{ needs.deploy-certificates.outputs.environment }}"
          source config/env.$ENV

          echo "container_group_1=$CONTAINER_GROUP_1" >> $GITHUB_OUTPUT
          echo "container_group_2=$CONTAINER_GROUP_2" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "deploy_dual_brokers=$DEPLOY_DUAL_BROKERS" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check mqtt-1 status
        run: |
          echo "Checking ${{ steps.env.outputs.container_group_1 }} status..."

          STATE=$(az container show \
            --resource-group ${{ steps.env.outputs.resource_group }} \
            --name ${{ steps.env.outputs.container_group_1 }} \
            --query "containers[0].instanceView.currentState.state" -o tsv)

          echo "State: $STATE"

          if [ "$STATE" != "Running" ]; then
            echo "âŒ Container not running!"
            exit 1
          fi

          echo "âœ… mqtt-1 is running"

      - name: Check mqtt-2 status
        if: steps.env.outputs.deploy_dual_brokers == 'true'
        run: |
          echo "Checking ${{ steps.env.outputs.container_group_2 }} status..."

          STATE=$(az container show \
            --resource-group ${{ steps.env.outputs.resource_group }} \
            --name ${{ steps.env.outputs.container_group_2 }} \
            --query "containers[0].instanceView.currentState.state" -o tsv)

          echo "State: $STATE"

          if [ "$STATE" != "Running" ]; then
            echo "âŒ Container not running!"
            exit 1
          fi

          echo "âœ… mqtt-2 is running"

      - name: Deployment Summary
        run: |
          echo "## ðŸŽ‰ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.deploy-certificates.outputs.environment }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.deploy-certificates.outputs.image_built }}" == "true" ]; then
            echo "**Image:** ${{ needs.deploy-certificates.outputs.image_full }} ðŸ†•" >> $GITHUB_STEP_SUMMARY
            echo "**Build:** New image built and deployed" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Image:** ${{ needs.deploy-certificates.outputs.image_full }}" >> $GITHUB_STEP_SUMMARY
            echo "**Build:** Used existing image (no docker changes)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "**Containers:** Running" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
